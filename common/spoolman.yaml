globals:
  - id: location_index
    type: int
    initial_value: '0'
  - id: total_locations
    type: int
    initial_value: '0'
  - id: selected_location_id
    type: int
    initial_value: '0'

http_request:
  useragent: esphome/filamentscale

api:
  actions:
    - action: set_spool_id_manual
      variables:
        spool_id: int
      then:
        - lambda: 'id(current_spool_id) = spool_id;'
        - script.execute: fetch_spoolman_data
        
    - action: update_spool_location
      variables:
        spool_id: int
        location_name: string
      then:
        - http_request.post:
            url: !lambda |-
              return "http://${spoolman_ip}/api/v1/spool/" + std::to_string(spool_id);
            # Wir senden den fertigen JSON-String direkt als body
            body: !lambda |-
              return "{\"location\": {\"name\": \"" + location_name + "\"}}";
            on_response:
              then:
                - logger.log: "Standort erfolgreich aktualisiert!"

# Hier definieren wir die Sensoren, die die Daten halten
sensor:
  - platform: template
    name: "Spoolman Remaining Weight"
    id: spoolman_remaining_weight
    unit_of_measurement: "g"
    icon: "mdi:weight-gram"
    accuracy_decimals: 1

text_sensor:
  - platform: template
    id: spool_status_text
    name: "Spool Status"
    
  - platform: template
    id: current_location_name
    internal: true
    
  - platform: template
    id: spool_location_text
    name: "Spool Location"
    internal: true
    
  - platform: template
    id: spool_filament_name
    name: "Aktuelles Filament"
    icon: mdi:printer-3d-nozzle

  - platform: template
    id: spool_material_text
    name: "Filament Material"
    icon: mdi:database

  - platform: template
    id: spoolman_response_raw
    on_value:
      then:
        - lambda: |-
            auto json_doc = json::parse_json(x);
            if (json_doc.as<JsonVariant>().isNull()) {
              id(spool_status_text).publish_state("ID UNGÜLTIG");
              id(spoolman_remaining_weight).publish_state(NAN);
              return;
            }
            auto root = json_doc.as<JsonObject>();
            bool is_archived = root["archived"] | false;
            
            if (is_archived) {
              id(spool_status_text).publish_state("ARCHIVIERT");
              id(spoolman_remaining_weight).publish_state(NAN);
            } else {
              id(spool_status_text).publish_state("AKTIV");
              id(spoolman_remaining_weight).publish_state(root["remaining_weight"] | 0.0);
            }

script:
  - id: fetch_location_list
    then:
      - http_request.get:
          url: !lambda |-
            return "http://${spoolman_ip}/api/v1/location";
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  // Wir nutzen auch hier content, um konsistent zu bleiben
                  auto json_doc = json::parse_json(body);
                  if (json_doc.as<JsonVariant>().isNull()) return;
                  auto arr = json_doc.as<JsonArray>();
                  id(total_locations) = arr.size();
                  if (id(location_index) < id(total_locations)) {
                    JsonObject loc = arr[id(location_index)];
                    id(current_location_name).publish_state(loc["name"] | "Unbekannt");
                    id(selected_location_id) = loc["id"] | 0;
                  }

  - id: fetch_spoolman_data
    mode: restart
    then:
      - lambda: |-
          id(spool_status_text).publish_state("LÄDT...");
          id(spool_location_text).publish_state("-");
      - http_request.get:
          url: !lambda |-
            return "http://${spoolman_ip}/api/v1/spool/" + std::to_string(id(current_spool_id));
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  auto json_doc = json::parse_json(body);
                  if (json_doc.as<JsonVariant>().isNull()) {
                    id(spool_status_text).publish_state("SERVER FEHLER");
                    return;
                  }
                  auto roort = json_doc.as<JsonObject>();
                  
                  // Prüfung: Ist es eine gültige Spule?
                  if (root.containsKey("filament")) {
                    // ERFOLG-PFAD
                    bool archived = root["archived"] | false;
                    id(spool_status_text).publish_state(archived ? "ARCHIVIERT" : "AKTIV");
                    
                    std::string f_name = root["filament"]["name"] | "Unbekannt";
                    id(spool_filament_name).publish_state(f_name.c_str());
                   
                    std::string loc = root["location"]["name"] | "Kein Ort";
                    id(spool_location_text).publish_state(loc.c_str());
                  } 
                  else if (root.containsKey("message")) {
                    // FEHLER-PFAD (z.B. "No spool with ID...")
                    std::string msg = root["message"] | "Fehler";
                    id(spool_status_text).publish_state(msg.c_str());
                    id(spool_location_text).publish_state("-");
                    id(spool_filament_name).publish_state("N/A");
                  }