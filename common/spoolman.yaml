globals:
  - id: location_index
    type: int
    initial_value: '0'
  - id: total_locations
    type: int
    initial_value: '0'
  - id: selected_location_id
    type: int
    initial_value: '0'

http_request:
  useragent: esphome/filamentscale

api:
  actions:
    - action: set_spool_id_manual
      variables:
        spool_id: int
      then:
        - lambda: 'id(current_spool_id) = spool_id;'
        - script.execute: fetch_spoolman_data
        
    - action: update_spool_location
      variables:
        spool_id: int
        location_name: string
      then:
        - http_request.post:
            url: !lambda |-
              return "http://${spoolman_ip}/api/v1/spool/" + std::to_string(spool_id);
            # Wir senden den fertigen JSON-String direkt als body
            body: !lambda |-
              return "{\"location\": {\"name\": \"" + location_name + "\"}}";
            on_response:
              then:
                - logger.log: "Standort erfolgreich aktualisiert!"

# Hier definieren wir die Sensoren, die die Daten halten
sensor:
  - platform: template
    name: "Spoolman Remaining Weight"
    id: spoolman_remaining_weight
    unit_of_measurement: "g"
    icon: "mdi:weight-gram"
    accuracy_decimals: 1

text_sensor:
  - platform: template
    id: spool_status_text
    name: "Spool Status"
    
  - platform: template
    id: current_location_name
    internal: true
    
  - platform: template
    id: spool_location_text
    name: "Spool Location"
    internal: true

  - platform: template
    id: spoolman_response_raw
    on_value:
      then:
        - lambda: |-
            auto json_doc = json::parse_json(x);
            if (json_doc.as<JsonVariant>().isNull()) {
              id(spool_status_text).publish_state("ID UNGÜLTIG");
              id(spoolman_remaining_weight).publish_state(NAN);
              return;
            }
            auto root = json_doc.as<JsonObject>();
            bool is_archived = root["archived"] | false;
            
            if (is_archived) {
              id(spool_status_text).publish_state("ARCHIVIERT");
              id(spoolman_remaining_weight).publish_state(NAN);
            } else {
              id(spool_status_text).publish_state("AKTIV");
              id(spoolman_remaining_weight).publish_state(root["remaining_weight"] | 0.0);
            }

script:
  - id: fetch_location_list
    then:
      - http_request.get:
          url: !lambda |-
            return "http://${spoolman_ip}/api/v1/location";
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  auto json_doc = json::parse_json(body);
                  if (json_doc.as<JsonVariant>().isNull()) return;
                    auto arr = json_doc.as<JsonArray>();
                    
                    id(total_locations) = arr.size();
                    
                    // Den Namen für den aktuell gewählten Index extrahieren
                    if (id(location_index) < id(total_locations)) {
                      JsonObject loc = arr[id(location_index)];
                      id(current_location_name).publish_state(loc["name"] | "Unbekannt");
                      // WICHTIG: Wir müssen uns die ID merken, um sie später zu senden
                      id(selected_location_id) = loc["id"] | 0;
                    }

  - id: fetch_spoolman_data
      mode: restart
      then:
        - lambda: |-
            // Reset der Anzeige während des Ladens
            id(spool_status_text).publish_state("LÄDT...");
            id(spool_location_text).publish_state("-");
        - http_request.get:
            url: !lambda |-
              return "http://${spoolman_ip}/api/v1/spool/" + std::to_string(id(current_spool_id));
            capture_response: true
            on_response:
              then:
                - lambda:
                    content: |-
                      if (status_code == 200) {
                        auto json_doc = json::parse_json(body);
                        // Sicherstellen, dass das JSON valide ist
                        if (json_doc.as<JsonVariant>().isNull()) return;
                        auto root = json_doc.as<JsonObject>();
                          
                        // 1. Status & Ort
                        bool archived = root["archived"] | false;
                        std::string loc = root["location"]["name"] | "Kein Ort";
                        id(spool_status_text).publish_state(archived ? "ARCHIVIERT" : "AKTIV");
                        id(spool_location_text).publish_state(loc.c_str());
                     
                        // 2. Filament Details (Name & Typ)
                        std::string f_name = root["filament"]["name"] | "Unbekannt";
                        std::string f_type = root["filament"]["material"] | "???";
                          
                        // 3. Gewichtsberechnung
                        float rem_weight = root["remaining_weight"] | 0.0f;
                          
                        ESP_LOGI("spoolman", "Spule geladen: %s (%s)", f_name.c_str(), f_type.c_str());
                      } else {
                          id(spool_status_text).publish_state("UNBEKANNT");
                          id(spool_location_text).publish_state("-");
                        }