globals:
  - id: location_index
    type: int
    initial_value: '0'
  - id: total_locations
    type: int
    initial_value: '0'

http_request:
  useragent: esphome/filamentscale

api:
  actions:
    - action: set_spool_id_manual
      variables:
        spool_id: int
      then:
        - lambda: 'id(current_spool_id) = spool_id;'
        - script.execute: fetch_spoolman_data
        
    - action: update_spool_location
      variables:
        spool_id: int
        location_name: string
      then:
        - http_request.post:
            url: !lambda |-
              return "http://${spoolman_ip}/api/v1/spool/" + std::to_string(spool_id);
            # Hier liegt der Fix: Wir bauen das JSON direkt im Lambda zusammen
            json: !lambda |-
              return "{\"location\": {\"name\": \"" + location_name + "\"}}";
            on_response:
              then:
                - logger.log: "Standort erfolgreich aktualisiert!"

# Hier definieren wir die Sensoren, die die Daten halten
sensor:
  - platform: template
    name: "Spoolman Remaining Weight"
    id: spoolman_remaining_weight
    unit_of_measurement: "g"
    icon: "mdi:weight-gram"
    accuracy_decimals: 1

text_sensor:
  - platform: template
    id: spool_status_text
    name: "Spool Status"
    
  - platform: template
    id: current_location_name
    internal: true

  - platform: template
    id: spoolman_response_raw
    on_value:
      then:
        - lambda: |-
            auto json_doc = json::parse_json(x);
            if (json_doc.as<JsonVariant>().isNull()) {
              id(spool_status_text).publish_state("ID UNGÜLTIG");
              id(spoolman_remaining_weight).publish_state(NAN);
              return;
            }
            auto root = json_doc.as<JsonObject>();
            bool is_archived = root["archived"] | false;
            
            if (is_archived) {
              id(spool_status_text).publish_state("ARCHIVIERT");
              id(spoolman_remaining_weight).publish_state(NAN);
            } else {
              id(spool_status_text).publish_state("AKTIV");
              id(spoolman_remaining_weight).publish_state(root["remaining_weight"] | 0.0);
            }

script:
  script:
  - id: fetch_location_list
    then:
      - http_request.get:
          url: !lambda |-
            return "http://${spoolman_ip}/api/v1/location";
          on_response:
            then:
              - lambda: |-
                  auto json_doc = json::parse_json(body);
                  if (json_doc.as<JsonVariant>().isNull()) return;
                    auto arr = json_doc.as<JsonArray>();
                    
                    id(total_locations) = arr.size();
                    
                    // Den Namen für den aktuell gewählten Index extrahieren
                    if (id(location_index) < id(total_locations)) {
                      JsonObject loc = arr[id(location_index)];
                      id(current_location_name).publish_state(loc["name"] | "Unbekannt");
                      // WICHTIG: Wir müssen uns die ID merken, um sie später zu senden
                      id(selected_location_id) = loc["id"] | 0;
                    }

  - id: fetch_spoolman_data
    then:
      - if:
          condition:
            lambda: 'return id(current_spool_id) > 0;'
          then:
            - http_request.get:
                url: !lambda |-
                  std::string url = "http://${spoolman_ip}/api/v1/spool/";
                  url += std::to_string(id(current_spool_id));
                  ESP_LOGI("spoolman", "URL: %s", url.c_str());
                  return url;
                capture_response: true
                on_response:
                  then:
                    - text_sensor.template.publish:
                        id: spoolman_response_raw
                        state: !lambda "return body;"
          else:
            - lambda: 'esphome::scale_logic::_appState = esphome::scale_logic::STATE_MAIN;'
